from pathlib import Path
from pydantic import Field, BaseModel
from script2runner import CLI
from typing import List, Literal, Dict, ClassVar, Annotated
import shutil, datetime as dt
import yaml
import re
import subprocess, sys
import time

start_path_patterns = ["/media/filer2/T4b/", "/media/filer2/T4/", "/media/t4user/data1/", "/media/BigNAS/", "/home/t4user/"]
def get_file_pattern_from_suffix_list(start_path_patterns, suffixes):
    def mk_or_pattern(options):
        return '(('+ ")|(".join([re.escape(opt) for opt in options])+ '))'
    return '^'+ mk_or_pattern(start_path_patterns)+r'[^\\]*'+ mk_or_pattern(suffixes) + "$"
    


class Args(CLI):
    """
        - Goal: Spikesorts a spikeinterface (usually preprocessed) recording. 
        - Technique: It applies kilosort4. 
        - Formats: Input and output formats are in the .zarr formats generated by spike interface.
    """
    recording_path: Annotated[Path, Field(
        description="Path to the folder containing the (usually preprocessed) recording",
        examples=["/media/t4user/data1/Data/SpikeSorting/...si.zarr"], 
        json_schema_extra=dict(pattern=get_file_pattern_from_suffix_list(start_path_patterns, [".si.zarr"]))
    )]
    output_path: Annotated[Path, Field(
        examples=["/media/filer2/T4b/Temporary/....si.zarr"], 
        description="Location of the output", 
        json_schema_extra=dict(pattern=get_file_pattern_from_suffix_list(start_path_patterns, [".si.zarr"]))
    )]
    overwrite: Literal["yes", "no"] = Field(default="no", description="Whether to overwrite and continue if output exists")
    _run_info: ClassVar = dict(conda_env="ssnew", cpu_usage=5.0, memory_usage=10.0, gpu_usage=1.0)
    
a = Args()

if a.output_path.exists():
    if a.overwrite =="no":
        print(f"{a.output_path} already exists")
        exit(2)
    else:
        shutil.rmtree(a.output_path)
        a.output_path.parent.mkdir(exist_ok=True, parents=True)

import spikeinterface.extractors as sie
import spikeinterface as si
import spikeinterface.sorters as sis


tmp_sorter_path = Path(f"/home/t4user/tmp_spike_sorting/{dt.datetime.now()}")
if tmp_sorter_path.exists():
    raise Exception(f"Path {tmp_sorter_path} should not exist...")
rec : si.BaseRecording = si.load(a.recording_path)
print(rec)
if shutil.disk_usage(tmp_sorter_path.parent).free < 2*rec.get_memory_size():
    raise Exception(f"They may be not enough free space at location {tmp_sorter_path.parent} (we take factor 2 margin). Free space: {shutil.disk_usage(tmp_sorter_path.parent).free}. Expected size: {rec.get_memory_size()}.")
print(f"At location {tmp_sorter_path.parent} free space: {shutil.disk_usage(tmp_sorter_path.parent).free}. Expected size: {rec.get_memory_size()}.")
print(f"Sorting called with temporary path {tmp_sorter_path}")
sys.stdout.flush()
tmp_result_path = a.output_path.with_stem(".tmp_"+a.output_path.stem)
if tmp_result_path.exists():
    shutil.rmtree(tmp_result_path)
sorting: si.BaseSorting = sis.run_sorter(recording = rec, folder=tmp_sorter_path, do_CAR= False, do_correction= False, skip_kilosort_preprocessing= False, sorter_name="kilosort4")
sorting.save(format="zarr", folder=tmp_result_path)
shutil.rmtree(tmp_sorter_path)
try:
    shutil.move(tmp_result_path, a.output_path)
except Exception as e: #Stupid problem due to cifs mount
    print(f"Got exception {e} when trying to move result, checking that result is ok anyway")
    p = subprocess.run(["diff", "-r", tmp_result_path, a.output_path], check=True, stdout=subprocess.PIPE, text=True)
    if p.stdout.strip()=="":
        print("No differences found...")
        shutil.rmtree(tmp_result_path)
    else:
        print(f"Differences found {p.stdout}")
        exit(2)
    